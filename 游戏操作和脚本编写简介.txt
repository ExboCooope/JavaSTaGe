%重要%
请使用最新Chrome浏览器运行游戏

启动游戏：
运行启动网页服务器.bat，会在本地3000端口启动网页服务，访问http://localhost:3000/即可


游戏默认操作：

shift 低速
Z 射击/确认
X 丢雷(暂时无用)/返回
C 用户自定义按键
ESC 暂停/退出全屏   （可以将暂停绑上其它键，用来在全屏时暂停）
方向键 移动
F 全屏


关卡选择：

在开始界面按任意键进入开始菜单
在开始界面按R可以重置按键绑定
选择开始菜单中的游戏开始，之后选择关卡即可	(GAME/default_menu_script.js)
目前的关卡没有自动结束，请按暂停（ESC）键，选择结束游戏 	(GAME/default_pause_script.js)
在菜单按返回键可以返回上一级菜单或开始界面


联机方法：
目前的服务器支持多人多房间，但是默认的联机脚本只能两人联机（自动加入房间、房间满两人开始） 
联机前，先开启联机服务器（自带的联机服务器的node.exe为64位程序，如果你的电脑用的32位操作系统，请自行搜索"node.js"下载32位node.exe）
将GAME/default_multiplayer_script.js中的stg_mp_ip=[192,168,0,100,3010]，前4位数改为服务器地址
联机输入延迟也在GAME/default_multiplayer_script.js中，没有自动确定，如果联机帧数下降，请根据网络延迟情况手动调整第62行stgCreateInput(3)中的整数参数，越大帧数越高
设置好后，进入游戏，选择切换为多人模式，会连接服务器，成功显示“玩家数：1”，当玩家数为2时，联机成功，选项变为“切换为单人模式”
联机成功后两人共享系统操作，选择开始游戏、关卡，会出现两个自机，分别由双方控制。
联机也可以保存replay，联机的replay可以单机观看，但是如果想联机观看replay，请保证双方都打开了同一个replay
（联机服务器和网页服务器不一定在一个IP，用两份游戏在两台电脑上连接第三方的联机服务器也可）

Replay：
游戏结束时，会提示保存replay，选择会自动下载这次的replay文件，默认在"文档/下载"中。游戏也会存储最后一次的replay。
将replay文件拖入游戏界面可以打开replay。
在主菜单选择播放replay即可播放当前的replay。

若想保证你设计的关卡replay不出现错误，请不要在游戏脚本中使用Math.random（请使用stg_rand），也不要使用系统输入或者键盘其他按键的输入(只使用player.key)


按键设置
菜单脚本中有按键设置功能，一个功能键可以绑定到多个实体按键上。
手柄和摇杆的按键号大于1000
如果识别不出手柄或摇杆，请在插入后刷新页面
游戏带有记忆手柄摇杆功能，同一个手柄只用绑定一次按键


致开发者：
JavaScript快速入门

JavaScript中的值分为两种，值和对象
值： 0,1,2,3,"1234",null,undefined  所有数为双精度，字符串可进行直接比对"123"=="123" (true) undefined为未定义 null为空
对象： [1,2,3]  数组
	{a:1,b:2,c:3} 对象
	function(){} 函数  
对象皆为指针

声明变量
var a=0; //a是0
var b={ }; //b是一个新的空对象
var c=function(){}; //c是一个新的函数
//基本等效于 function c(){ }
var d=[]; //d是一个空数组
b.x=[]; //声明了b的属性为一个空数组，这时b指向的对象为{x:[]}
d[0]=23; //声明了d的下标为0的元素为23
b["y"]="123"; //声明了b中的属性y为字符串"123"，这时b指向的对象为{x:[],y:"123"}
//b c d皆为对象，以上三种方法可以混用
//b[0]=0; d.a=1; c.r=[]; 这些声明都能正确访问

使用值
b.x=a;//b.x由[]变成了1
使用数组
a=d[0];//a变成了23,b.x仍为1，值复制后不会跟着改变
d.push(b);//d[1]变成了对象b
使用对象
b.y=b.x;//b指向的对象为{x:[],y:[]}，其中这两个数组是同一个对象
b.x[0]=1;//b指向的对象为{x:[1],y:[1]}, d[1]=={x:[1],y:[1]}
b={};//b指向一个新的对象，但是d[1]仍为之前的b对象
使用函数
c();

类
类一般为大写字母的函数作为主体
function Class1(a){  //一个函数叫Class1 将可以作为构造函数
	this.a=a;    //this指向调用函数的主体，当函数被用作构造时，this指向新的对象
	//构造函数没有返回值
}
//每个函数都有prototype属性
Class1.prototype.getA=function(){  //将Class1的prototype的getA属性设置成一个函数
	return this.a;	//这个函数返回调用该函数对象的a属性
}
var u=new Class1(1); //使用new关键字构造新对象，新对象的a属性被Class1函数设置成1，并且该对象会拥有Class1.prototye的所有属性
u.a==1;//真
u.getA()==1;//真

条件语句
if(***)***;
if(***){***}
if(***){***}else{***}
if(***){***}else if(***){***}else ...
while(***)***;
while(***){***};
for(***;***;***){***}
for(***1 in ***2){***} 可以遍历***2的属性，并将属性字符串赋值给***1变量，注意为字符串。使用时可以 ***2[***1]

JavaScript设计思路 对象为主，将需要的对象设计好。函数也是对象
构造对象的方法：
直接值 
var a={d:1,e:[],f:function(){...}}
工厂函数
function a1(){
	var a={};
	a.d=1;
	a.e=[];
	a.f=function(){...};
	return a;
}
var a=a1();
类
function A1(){
	this.d=1;
	this.e=[];
}
A1.prototype.f=function(){...};
var a=new A1();
属性函数
function a_1(a){
	a.d=1;
	a.e=[];
	a.f=function(){...};
}
var a={};
a_1(a);

函数中可以引用声明该函数所在脚本的变量，但是访问时是其变量最终的值
function a1(){
	var a=1;
	var b=function(){return a;} //b函数可以访问构造它的a1函数中的临时变量a
	return b;
}
var t=a1();
t()==1;
function a2(){
	var a=1;
	var b=function(){return a;}; //b函数可以访问构造它的a1函数中的临时变量a，该临时变量会被系统变为持续变量
	var c=[a];
	a++;  //a++会影响b函数中引用的a的值，但是不会影响c数组
	var d=function(){a=10;};
	return [b,c,d];
}
var t=a2(); //(1)
t[0]()==2;
t[1][0]==1;
t[2](); //这个函数将 (1)执行的a2 中的a变成了10
t[0]()==10;
var t2=a2(); //两次执行函数a2将产生两个a，互不影响
t[0]()==10;
t2[0]()==2;

关于this
function a1(){
	return this.a;
}
var b={a:1};
b.k=a1;
b.k()==1;
var d={};
d.k=a1;
d.k()===undefined;
